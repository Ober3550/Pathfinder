<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, user-scalable=no">
<script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>
<script>
function Node(pos,value) {
    this.value = value;
    this.parent = null;
}
let colors = ['black','white','orange','yellow','red','cyan','purple','grey'];
let board = [];
let updateBoard = [];
let timer = 0;
let pauseGame = true;
let boardWidth  = 21;
let boardHeight = 21;
let finished = false;
let lastPassage = [[0,0]];
let includeDiags = false;
function setup() {    
    createCanvas(windowWidth, windowHeight);    
    background(255);
    //frameRate(5);
    board = [];
    for(let i=0;i<boardWidth;i++){
        let inner = [];
        for(let j=0;j<boardHeight;j++){    
            inner.push(new Node([i,j],0));
        }
        board.push(inner);
    }
    board[0][0].value = 4;
    board[14][16].value = 6;
}
function carve_passages_from(pos){
    queueNeighbour([pos[0],pos[1]],1);
    // Shuffle array
    for(let i=orth.length-1;i>0;i--){
        let j = Math.floor(Math.random() * i)
        let temp = orth[i]
        orth[i] = orth[j]
        orth[j] = temp
    }
    // Randomly check if a passage can be made
    for(let i=0;i<orth.length;i++){
        let neighbourPos = [pos[0]+orth[i][0]*2,pos[1]+orth[i][1]*2];
        let neighbour = getNeighbour(neighbourPos);
        if(neighbour == 0 || neighbour == 6){
            queueNeighbour([pos[0]+orth[i][0],pos[1]+orth[i][1]],1);
            lastPassage.push(neighbourPos);
            return;
        }
    }
    lastPassage.pop();
}
// Safety function so that 
// index out of bounds doesn't occur
function getNeighbour(pos){
    if(
    pos[0] < 0 || 
    pos[0] >= boardWidth || 
    pos[1] < 0 || 
    pos[1] >= boardHeight
    )
        return 7;
    return board[pos[0]][pos[1]].value;
}
function queueNeighbour(pos,value){
    updateBoard.push([pos,value]);
}
function setNeighbour(pos, value){
    if(
    pos[0] < 0 || 
    pos[0] >= boardWidth || 
    pos[1] < 0 || 
    pos[1] >= boardHeight
    )
        return;
    let currValue = board[pos[0]][pos[1]].value;
    if(currValue != 4 && currValue != 5)
    board[pos[0]][pos[1]].value = value;
    if(currValue == 6)
    board[pos[0]][pos[1]].value = 5;
}
function findRoute(node){
    if(node.parent != null)
    {
        node.value = 6;
        findRoute(node.parent);
    }
}
function finish(i,j){
    // Tell the program to no longer update
    finished = true;
    // Recursively draw the route
    findRoute(board[i][j]);
    // Clear the active and visited nodes
    for(let i=0;i<boardWidth;i++){
        for(let j=0;j<boardHeight;j++){
            if(board[i][j].value == 2 || board[i][j].value == 3){
                board[i][j].value = 1;
            }
        }
    }
    // Clear the update array
    updateBoard = [];
    // Stop applying updates to the board
}
let orth = [[-1, 0],[ 0,-1],[ 1, 0],[ 0, 1]];
let diag = [[ 1, 1],[ 1,-1],[-1, 1],[-1,-1]];
function stepGame(){
    let breakall = false;
    timer++;
    if(timer == 1){
        timer = 0;
        // Treat the array like a stack since it's 'recursive'
        if(lastPassage.length > 0){
            carve_passages_from(lastPassage[lastPassage.length-1]);
        }
        else if(!finished){
            for(let i=0;i<boardWidth;i++){
                for(let j=0;j<boardHeight;j++)
                {
                    if(board[i][j].value == 2 || board[i][j].value == 4){
                        // Orthographic checks
                        for(let o=0;o<4;o++){
                            // Check if finished
                            if(getNeighbour([i+orth[o][0],j+orth[o][1]]) == 5){
                                finish(i,j);
                                breakall = true;
                                break;
                            }
                            if(getNeighbour([i+orth[o][0],j+orth[o][1]]) == 1){
                                queueNeighbour([i+orth[o][0],j+orth[o][1]],2); 
                                board[i+orth[o][0]][j+orth[o][1]].parent = board[i][j]; 
                            }
                        }
                        if(breakall) break;
                        // Diagonal checks
                        if(includeDiags){
                            for(let o=0;o<4;o++){
                                // Check if finished
                                if(getNeighbour([i+diag[o][0],j+diag[o][1]]) == 5){
                                    finish(i,j);
                                    breakall = true;
                                    break;
                                }
                                // Extra functionality is to ensure that nodes don't 
                                // take their neighbours tile in case of a diagonal
                                if(getNeighbour([i+diag[o][0],j+diag[o][1]]) == 1 &&
                                   getNeighbour([i           ,j+diag[o][1]]) != 2 &&
                                   getNeighbour([i+diag[o][0],j           ]) != 2)
                                {
                                    queueNeighbour([i+diag[o][0],j+diag[o][1]],2); 
                                    board[i+diag[o][0]][j+diag[o][1]].parent = board[i][j]; 
                                }
                            }
                            if(breakall) break;
                        }
                        queueNeighbour([i,j],3);
                    }
                }
            }
        }
        for(let i=0;i<updateBoard.length;i++){
            setNeighbour(updateBoard[i][0],updateBoard[i][1]);
        }
        updateBoard = [];
    }
}
function draw() {
    clear();
    background(255);
    stepSize = windowHeight/boardHeight;
    xOff = (windowWidth/2) - (stepSize * boardWidth/2);
    if(!pauseGame){
        stepGame();
    }
    // Draw the board
    for(let i=0;i<board.length;i++)
    {
        for(let j=0;j<board[i].length;j++)
        {
            fill(colors[board[i][j].value]);
            if(lastPassage.length > 0){
                let runner = lastPassage[lastPassage.length-1];
                if(runner[0] == i && runner[1] == j)
                {
                    fill('red');
                }
            }
            rect(xOff+i*stepSize,j*stepSize,stepSize,stepSize);
        }
    }
}
function keyPressed()
{
    if(keyCode == ESCAPE){
        pauseGame = !pauseGame;
    }
}
function windowResized() {
    setup();
}
</script>
</head>
<body style="margin: 0">
</body>
</html>