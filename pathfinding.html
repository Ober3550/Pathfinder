<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, user-scalable=no">
<script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>
<script>
function Node(pos,value) {
    this.value = value;
    this.parent = null;
}
let colors = ['black','white','orange','yellow','red','cyan','purple'];
let board = [];
let updateBoard = [];
let timer = 0;
let pauseGame = false;
let boardWidth  = 100;
let boardHeight = 100;
let finished = false;
function setup() {    
    createCanvas(windowWidth, windowHeight);    
    background(255);
    //frameRate(5);
    board = [];
    for(let i=0;i<boardWidth;i++){
        let inner = [];
        for(let j=0;j<boardHeight;j++){    
            inner.push(new Node([i,j],1));
        }
        board.push(inner);
    }
    board[0][3].value = 4;
    board[30][40].value = 5;
    // Vertical wall
    for(let i=0;i<40;i++)
    {
        board[10][i+10].value = 0;
    }
    for(let i=0;i<40;i++)
    {
        board[i+5][30].value = 0;
    }
}
// Safety function so that 
// index out of bounds doesn't occur
function getNeighbour(pos){
    if(
    pos[0] < 0 || 
    pos[0] >= boardWidth || 
    pos[1] < 0 || 
    pos[1] >= boardHeight
    )
        return 0;
    return board[pos[0]][pos[1]].value;
}
function queueNeighbour(pos,value){
    updateBoard.push([pos,value]);
}
function setNeighbour(pos, value){
    if(
    pos[0] < 0 || 
    pos[0] >= boardWidth || 
    pos[1] < 0 || 
    pos[1] >= boardHeight
    )
        return;
    board[pos[0]][pos[1]].value = value;
}
function findRoute(node){
    if(node.parent != null)
    {
        node.value = 6;
        findRoute(node.parent);
    }
}
function finish(i,j){
    // Tell the program to no longer update
    finished = true;
    // Recursively draw the route
    findRoute(board[i][j]);
    // Clear the active and visited nodes
    for(let i=0;i<boardWidth;i++){
        for(let j=0;j<boardHeight;j++){
            if(board[i][j].value == 2 || board[i][j].value == 3){
                board[i][j].value = 1;
            }
        }
    }
    // Clear the update array
    updateBoard = [];
    // Stop applying updates to the board
}
let orth = [[-1, 0],[ 0,-1],[ 1, 0],[ 0, 1]];
let diag = [[ 1, 1],[ 1,-1],[-1, 1],[-1,-1]];
function stepGame(){
    let breakall = false;
    timer++;
    if(timer == 1){
        timer = 0;
        if(!finished){
            for(let i=0;i<boardWidth;i++){
                for(let j=0;j<boardHeight;j++)
                {
                    if(board[i][j].value == 2 || board[i][j].value == 4){
                        // Orthographic checks
                        for(let o=0;o<4;o++){
                            // Check if finished
                            if(getNeighbour([i+orth[o][0],j+orth[o][1]]) == 5){
                                finish(i,j);
                                breakall = true;
                                break;
                            }
                            if(getNeighbour([i+orth[o][0],j+orth[o][1]]) == 1){
                                queueNeighbour([i+orth[o][0],j+orth[o][1]],2); 
                                board[i+orth[o][0]][j+orth[o][1]].parent = board[i][j]; 
                            }
                        }
                        if(breakall) break;
                        // Diagonal checks
                        for(let o=0;o<4;o++){
                            // Check if finished
                            if(getNeighbour([i+diag[o][0],j+diag[o][1]]) == 5){
                                finish(i,j);
                                breakall = true;
                                break;
                            }
                            // Extra functionality is to ensure that nodes don't 
                            // take their neighbours tile in case of a diagonal
                            if(getNeighbour([i+diag[o][0],j+diag[o][1]]) == 1 &&
                               getNeighbour([i           ,j+diag[o][1]]) != 2 &&
                               getNeighbour([i+diag[o][0],j           ]) != 2)
                            {
                                queueNeighbour([i+diag[o][0],j+diag[o][1]],2); 
                                board[i+diag[o][0]][j+diag[o][1]].parent = board[i][j]; 
                            }
                        }
                        if(breakall) break;
                        // Don't change color if it's the start
                        if(board[i][j].value == 2){
                            queueNeighbour([i,j],3);
                        }
                    }
                }
            }
            for(let i=0;i<updateBoard.length;i++){
                setNeighbour(updateBoard[i][0],updateBoard[i][1]);
            }
            updateBoard = [];
        }
    }
}
function draw() {
    clear();
    background(255);
    stepSize = windowHeight/boardHeight;
    xOff = (windowWidth/2) - (stepSize * boardWidth/2);
    if(!pauseGame){
        stepGame();
    }
    // Draw the board
    for(let i=0;i<board.length;i++)
    {
        for(let j=0;j<board[i].length;j++)
        {
            fill(colors[board[i][j].value]);
            rect(xOff+i*stepSize,j*stepSize,stepSize,stepSize);
        }
    }
}
function keyPressed()
{
    if(keyCode == ESCAPE){
        pauseGame = !pauseGame;
    }
}
function windowResized() {
    setup();
}
</script>
</head>
<body style="margin: 0">
</body>
</html>